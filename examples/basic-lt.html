<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Basic Example — Networked-Aframe</title>
    <meta name="description" content="Basic Example — Networked-Aframe" />

    <script src="https://cdn.jsdelivr.net/gh/aframevr/aframe@40b81e61bc47d1fa83d244fc27234f87bfd05394/dist/aframe-master.min.js"></script>

    <!--   NAF basic requirements   -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js"></script>
    <!--<script src="/socket.io/socket.io.js"></script>-->
    <!--
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.5.0/socket.io.slim.js"></script>
    <script src="/easyrtc/easyrtc.js"></script>
    -->
    <script src="/dist/networked-aframe.js"></script>

    <!--    used for flying in this demo  -->
    <script src="https://cdn.jsdelivr.net/gh/c-frame/aframe-extras@7.5.2/dist/aframe-extras.controls.min.js"></script>

    <!--   used for the pretty environment   -->
    <script src="https://cdn.jsdelivr.net/npm/aframe-environment-component@1.4.0/dist/aframe-environment-component.min.js"></script>

    <!--   used to prevent players from spawning on top of each other so much  -->
    <script src="/js/spawn-in-circle.component.js"></script>

    <script>
      // Called by Networked-Aframe when connected to server (optional)
      // (this api will change in future versions)
      function onConnect() {
        console.log('onConnect', new Date());
      }

      // Note the way we're establishing the NAF schema here; this is a bit awkward
      // because of a recent bug found in the original handling. This mitigates that bug for now,
      // until a refactor in the future that should fix the issue more cleanly.
      // see issue https://github.com/networked-aframe/networked-aframe/issues/267

      // This one is necessary, because tracking the .head child component's material's color
      // won't happen unless we tell NAF to keep it in sync, like here.
      NAF.schemas.getComponentsOriginal = NAF.schemas.getComponents;
      NAF.schemas.getComponents = (template) => {
        if (!NAF.schemas.hasTemplate('#avatar-template')) {
          NAF.schemas.add({
            template: '#avatar-template',
            components: [
              // position and rotation are added by default if we don't include a template, but since
              // we also want to sync the color, we need to specify a custom template; if we didn't
              // include position and rotation in this custom template, they'd not be synced.
              {
                component: 'position',
                requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
              },
              {
                component: 'rotation',
                requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.5)
              },

              // this is how we sync a particular property of a particular component for a particular
              // child element of template instances.
              {
                selector: '.head',
                component: 'material',
                property: 'color' // property is optional; if excluded, syncs everything in the component schema
              },
              'player-info'
            ]
          });
        }

        if (!NAF.schemas.hasTemplate('#rig-template')) {
          NAF.schemas.add({
            template: '#rig-template',
            components: [
              {
                component: 'position',
                requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.001)
              },
              {
                component: 'rotation',
                requiresNetworkUpdate: NAF.utils.vectorRequiresUpdate(0.5)
              }
            ]
          });
        }

        const components = NAF.schemas.getComponentsOriginal(template);
        return components;
      };

      AFRAME.registerComponent('player-info', {
        schema: {
          name: { type: 'string', default: 'anonymous' },
          color: { type: 'color', default: '#ffffff' },
          muted: { type: 'boolean', default: false }
        },

        init: function () {
          this.head = this.el.querySelector('.head');
          this.nametag = this.el.querySelector('.nametag');
          this.updatedEventDetail = { el: undefined, data: undefined, oldData: undefined };
        },

        update: function (oldData) {
          this.updatedEventDetail.data = this.data;
          this.updatedEventDetail.oldData = oldData;
          this.updatedEventDetail.el = this.el;
          this.el.sceneEl.emit('player-info-updated', this.updatedEventDetail);
          this.updatedEventDetail.data = undefined;
          this.updatedEventDetail.oldData = undefined;
          this.updatedEventDetail.el = undefined;
          if (this.head) this.head.setAttribute('material', 'color', this.data.color);
          if (this.nametag) this.nametag.setAttribute('value', this.data.name);
        }
      });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/aframe-randomizer-components@3.0.2/dist/aframe-randomizer-components.min.js"></script>
  </head>
  <body>
    <!--serverURL: ws://192.168.1.15:8081/socket;-->
    <a-scene
      networked-scene="
      room: basic;
      debug: false;
      adapter: socketio;
      connectOnLoad: false;
    "
    >
      <a-assets>
        <!-- Templates -->
        <!-- Camera Rig / Player -->
        <template id="rig-template">
          <a-entity></a-entity>
        </template>

        <!-- Head / Avatar -->
        <!--      a few spheres make a head + eyes + pupils    -->
        <template id="avatar-template">
          <a-entity class="avatar" player-info networked-audio-source="positional: true">
            <!-- notice this child sphere, with class .head, has the random-color component; this modifies the material component's color property -->
            <a-sphere class="head" scale="0.2 0.22 0.2" random-color></a-sphere>
            <a-entity class="face" position="0 0.05 0">
              <a-sphere class="eye" color="white" position="0.06 0.05 -0.16" scale="0.04 0.04 0.04">
                <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
              </a-sphere>
              <a-sphere class="eye" color="white" position="-0.06 0.05 -0.16" scale="0.04 0.04 0.04">
                <a-sphere class="pupil" color="black" position="0 0 -1" scale="0.2 0.2 0.2"></a-sphere>
              </a-sphere>
            </a-entity>
          </a-entity>
        </template>
        <!-- /Templates -->
      </a-assets>

      <a-entity environment="preset:starry;groundColor:#000000;"></a-entity>
      <a-entity light="type:ambient;intensity:0.5"></a-entity>

      <!--   Here we declare only the local user's avatar, which we then broadcast to other users     -->
      <!--   The 'spawn-in-circle' component will set the position and rotation of #rig;
             because this entity also has the networked component, and position and rotation are tracked by default,
             the changes made by spawn-in-circle will be kept in sync with other networked users.
             Also note that by adding the networked component with a template reference, we generate that full template,
             including all applicable child elements. However, because we don't need to see our own avatar, we use the
             `attachTemplateToLocal:false` option. This makes our local copies invisible on our machine, but visible on everyone else's.
      -->
      <a-entity id="rig" movement-controls="fly:true;" spawn-in-circle="radius:3" networked="template:#rig-template;">
        <!-- Here we add the camera. Adding the camera within a 'rig' is standard practice.
         We set the camera to head height for e.g. computer users, but otherwise never touch it again; if the user enters VR,
         its rotation and position will be updated by the headset in VR. If we need to touch the user's position
         or rotation, we always do that by adjusting the rig parent of the active camera. By making that rig--and the
         active camera appended to it--both networked, we ensure all player movement is kept in sync.
        -->
        <a-entity
          id="player"
          camera
          position="0 1.6 0"
          look-controls
          networked="template:#avatar-template;"
          visible="false"
        >
        </a-entity>
      </a-entity>
    </a-scene>

    <script>
      // Called by Networked-Aframe when connected to server
      // Optional to use; this API will change in the future
      function onConnect() {
        console.log('onConnect', new Date());
      }
    </script>
    <script src="https://cdn.jsdelivr.net/gh/networked-aframe/naf-nametag-solidjs@49ccc23/public/dist/ui-components.js"></script>
    <style>
      /* You can override colors with css properties used by the ui components, see colors.css for the full list */
      :root {
        --panel-bg: #171717; /* bg-neutral-800 */
        --panel-text: #e2e8f0; /* text-slate-200 */
        --btn-primary-bg: #0f766e; /* bg-teal-700 */
        --btn-primary-bg-hover: #115e59; /* bg-teal-800 */
        --btn-primary-text: #e2e8f0; /* text-slate-200 */
        --btn-border-radius: 0.5rem; /* rounded-lg */
      }
    </style>

    <div class="naf-centered-fullscreen" id="enterScreen">
      <div style="display: flex; flex-direction: column; gap: 0.5rem">
        <label for="username">Your name</label>
        <!-- This needs to be after the a-scene so the player element can be found. -->
        <naf-username-input entity="#player" enable-color-picker="true"></naf-username-input>
        <!-- This sets name and color properties on your player-info component on #player entity -->
      </div>
      <button
        id="playButton"
        type="button"
        class="btn"
        style="min-width: 100px"
        onclick="javascript:AFRAME.scenes[0].emit('connect');this.parentNode.remove();document.getElementById('uiInRoom').removeAttribute('style')"
      >
        Enter
      </button>
    </div>

    <!--
      You can change the bar position with one of the following classes
      naf-top-bar-left naf-top-bar-center naf-top-bar-right
      naf-bottom-bar-left naf-bottom-bar-center naf-bottom-bar-right
    -->
    <div class="naf-bottom-bar-center" style="display: none" id="uiInRoom">
      <naf-mic-button entity="#player"></naf-mic-button>
      <!-- This sets muted property on your player-info component on #player entity -->
      <naf-users-button></naf-users-button>
      <naf-chat-button></naf-chat-button>
    </div>
  </body>
</html>
