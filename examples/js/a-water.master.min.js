THREE.GPUComputationRenderer=function(sizeX,sizeY,renderer){this.variables=[];this.currentTextureIndex=0;var scene=new THREE.Scene;var camera=new THREE.Camera;camera.position.z=1;var passThruUniforms={passThruTexture:{value:null}};var passThruShader=createShaderMaterial(getPassThroughFragmentShader(),passThruUniforms);var mesh=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),passThruShader);scene.add(mesh);this.addVariable=function(variableName,computeFragmentShader,initialValueTexture){var material=this.createShaderMaterial(computeFragmentShader);var variable={name:variableName,initialValueTexture:initialValueTexture,material:material,dependencies:null,renderTargets:[],wrapS:null,wrapT:null,minFilter:THREE.NearestFilter,magFilter:THREE.NearestFilter};this.variables.push(variable);return variable};this.setVariableDependencies=function(variable,dependencies){variable.dependencies=dependencies};this.init=function(){if(!renderer.extensions.get("OES_texture_float")&&!renderer.capabilities.isWebGL2){return"No OES_texture_float support for float textures."}if(renderer.capabilities.maxVertexTextures===0){return"No support for vertex shader textures."}for(var i=0;i<this.variables.length;i++){var variable=this.variables[i];variable.renderTargets[0]=this.createRenderTarget(sizeX,sizeY,variable.wrapS,variable.wrapT,variable.minFilter,variable.magFilter);variable.renderTargets[1]=this.createRenderTarget(sizeX,sizeY,variable.wrapS,variable.wrapT,variable.minFilter,variable.magFilter);this.renderTexture(variable.initialValueTexture,variable.renderTargets[0]);this.renderTexture(variable.initialValueTexture,variable.renderTargets[1]);var material=variable.material;var uniforms=material.uniforms;if(variable.dependencies!==null){for(var d=0;d<variable.dependencies.length;d++){var depVar=variable.dependencies[d];if(depVar.name!==variable.name){var found=false;for(var j=0;j<this.variables.length;j++){if(depVar.name===this.variables[j].name){found=true;break}}if(!found){return"Variable dependency not found. Variable="+variable.name+", dependency="+depVar.name}}uniforms[depVar.name]={value:null};material.fragmentShader="\nuniform sampler2D "+depVar.name+";\n"+material.fragmentShader}}}this.currentTextureIndex=0;return null};this.compute=function(){var currentTextureIndex=this.currentTextureIndex;var nextTextureIndex=this.currentTextureIndex===0?1:0;for(var i=0,il=this.variables.length;i<il;i++){var variable=this.variables[i];if(variable.dependencies!==null){var uniforms=variable.material.uniforms;for(var d=0,dl=variable.dependencies.length;d<dl;d++){var depVar=variable.dependencies[d];uniforms[depVar.name].value=depVar.renderTargets[currentTextureIndex].texture}}this.doRenderTarget(variable.material,variable.renderTargets[nextTextureIndex])}this.currentTextureIndex=nextTextureIndex};this.getCurrentRenderTarget=function(variable){return variable.renderTargets[this.currentTextureIndex]};this.getAlternateRenderTarget=function(variable){return variable.renderTargets[this.currentTextureIndex===0?1:0]};function addResolutionDefine(materialShader){materialShader.defines.resolution="vec2( "+sizeX.toFixed(1)+", "+sizeY.toFixed(1)+" )"}this.addResolutionDefine=addResolutionDefine;function createShaderMaterial(computeFragmentShader,uniforms){uniforms=uniforms||{};var material=new THREE.ShaderMaterial({uniforms:uniforms,vertexShader:getPassThroughVertexShader(),fragmentShader:computeFragmentShader});addResolutionDefine(material);return material}this.createShaderMaterial=createShaderMaterial;this.createRenderTarget=function(sizeXTexture,sizeYTexture,wrapS,wrapT,minFilter,magFilter){sizeXTexture=sizeXTexture||sizeX;sizeYTexture=sizeYTexture||sizeY;wrapS=wrapS||THREE.ClampToEdgeWrapping;wrapT=wrapT||THREE.ClampToEdgeWrapping;minFilter=minFilter||THREE.NearestFilter;magFilter=magFilter||THREE.NearestFilter;var renderTarget=new THREE.WebGLRenderTarget(sizeXTexture,sizeYTexture,{wrapS:wrapS,wrapT:wrapT,minFilter:minFilter,magFilter:magFilter,format:THREE.RGBAFormat,type:/(iPad|iPhone|iPod)/g.test(navigator.userAgent)?THREE.HalfFloatType:THREE.FloatType,stencilBuffer:false,depthBuffer:false});return renderTarget};this.createTexture=function(){var data=new Float32Array(sizeX*sizeY*4);return new THREE.DataTexture(data,sizeX,sizeY,THREE.RGBAFormat,THREE.FloatType)};this.renderTexture=function(input,output){passThruUniforms.passThruTexture.value=input;this.doRenderTarget(passThruShader,output);passThruUniforms.passThruTexture.value=null};this.doRenderTarget=function(material,output){var currentRenderTarget=renderer.getRenderTarget();mesh.material=material;var currentXrEnabled=renderer.xr.enabled;var currentShadowAutoUpdate=renderer.shadowMap.autoUpdate;renderer.xr.enabled=false;renderer.shadowMap.autoUpdate=false;renderer.setRenderTarget(output);renderer.clear();renderer.render(scene,camera);renderer.xr.enabled=currentXrEnabled;renderer.shadowMap.autoUpdate=currentShadowAutoUpdate;mesh.material=passThruShader;renderer.setRenderTarget(currentRenderTarget)};function getPassThroughVertexShader(){return"void main()\t{\n"+"\n"+"\tgl_Position = vec4( position, 1.0 );\n"+"\n"+"}\n"}function getPassThroughFragmentShader(){return"uniform sampler2D passThruTexture;\n"+"\n"+"void main() {\n"+"\n"+"\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n"+"\n"+"\tgl_FragColor = texture2D( passThruTexture, uv );\n"+"\n"+"}\n"}};THREE.BufferGeometryUtils={computeTangents:function(geometry){var index=geometry.index;var attributes=geometry.attributes;if(index===null||attributes.position===undefined||attributes.normal===undefined||attributes.uv===undefined){console.error("THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}var indices=index.array;var positions=attributes.position.array;var normals=attributes.normal.array;var uvs=attributes.uv.array;var nVertices=positions.length/3;if(attributes.tangent===undefined){geometry.setAttribute("tangent",new THREE.BufferAttribute(new Float32Array(4*nVertices),4))}var tangents=attributes.tangent.array;var tan1=[],tan2=[];for(var i=0;i<nVertices;i++){tan1[i]=new THREE.Vector3;tan2[i]=new THREE.Vector3}var vA=new THREE.Vector3,vB=new THREE.Vector3,vC=new THREE.Vector3,uvA=new THREE.Vector2,uvB=new THREE.Vector2,uvC=new THREE.Vector2,sdir=new THREE.Vector3,tdir=new THREE.Vector3;function handleTriangle(a,b,c){vA.fromArray(positions,a*3);vB.fromArray(positions,b*3);vC.fromArray(positions,c*3);uvA.fromArray(uvs,a*2);uvB.fromArray(uvs,b*2);uvC.fromArray(uvs,c*2);vB.sub(vA);vC.sub(vA);uvB.sub(uvA);uvC.sub(uvA);var r=1/(uvB.x*uvC.y-uvC.x*uvB.y);if(!isFinite(r))return;sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r);tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r);tan1[a].add(sdir);tan1[b].add(sdir);tan1[c].add(sdir);tan2[a].add(tdir);tan2[b].add(tdir);tan2[c].add(tdir)}var groups=geometry.groups;if(groups.length===0){groups=[{start:0,count:indices.length}]}for(var i=0,il=groups.length;i<il;++i){var group=groups[i];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){handleTriangle(indices[j+0],indices[j+1],indices[j+2])}}var tmp=new THREE.Vector3,tmp2=new THREE.Vector3;var n=new THREE.Vector3,n2=new THREE.Vector3;var w,t,test;function handleVertex(v){n.fromArray(normals,v*3);n2.copy(n);t=tan1[v];tmp.copy(t);tmp.sub(n.multiplyScalar(n.dot(t))).normalize();tmp2.crossVectors(n2,t);test=tmp2.dot(tan2[v]);w=test<0?-1:1;tangents[v*4]=tmp.x;tangents[v*4+1]=tmp.y;tangents[v*4+2]=tmp.z;tangents[v*4+3]=w}for(var i=0,il=groups.length;i<il;++i){var group=groups[i];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){handleVertex(indices[j+0]);handleVertex(indices[j+1]);handleVertex(indices[j+2])}}},mergeBufferGeometries:function(geometries,useGroups){var isIndexed=geometries[0].index!==null;var attributesUsed=new Set(Object.keys(geometries[0].attributes));var morphAttributesUsed=new Set(Object.keys(geometries[0].morphAttributes));var attributes={};var morphAttributes={};var morphTargetsRelative=geometries[0].morphTargetsRelative;var mergedGeometry=new THREE.BufferGeometry;var offset=0;for(var i=0;i<geometries.length;++i){var geometry=geometries[i];var attributesCount=0;if(isIndexed!==(geometry.index!==null)){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");return null}for(var name in geometry.attributes){if(!attributesUsed.has(name)){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+'. All geometries must have compatible attributes; make sure "'+name+'" attribute exists among all geometries, or in none of them.');return null}if(attributes[name]===undefined)attributes[name]=[];attributes[name].push(geometry.attributes[name]);attributesCount++}if(attributesCount!==attributesUsed.size){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". Make sure all geometries have the same number of attributes.");return null}if(morphTargetsRelative!==geometry.morphTargetsRelative){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". .morphTargetsRelative must be consistent throughout all geometries.");return null}for(var name in geometry.morphAttributes){if(!morphAttributesUsed.has(name)){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+".  .morphAttributes must be consistent throughout all geometries.");return null}if(morphAttributes[name]===undefined)morphAttributes[name]=[];morphAttributes[name].push(geometry.morphAttributes[name])}mergedGeometry.userData.mergedUserData=mergedGeometry.userData.mergedUserData||[];mergedGeometry.userData.mergedUserData.push(geometry.userData);if(useGroups){var count;if(isIndexed){count=geometry.index.count}else if(geometry.attributes.position!==undefined){count=geometry.attributes.position.count}else{console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+i+". The geometry must have either an index or a position attribute");return null}mergedGeometry.addGroup(offset,count,i);offset+=count}}if(isIndexed){var indexOffset=0;var mergedIndex=[];for(var i=0;i<geometries.length;++i){var index=geometries[i].index;for(var j=0;j<index.count;++j){mergedIndex.push(index.getX(j)+indexOffset)}indexOffset+=geometries[i].attributes.position.count}mergedGeometry.setIndex(mergedIndex)}for(var name in attributes){var mergedAttribute=this.mergeBufferAttributes(attributes[name]);if(!mergedAttribute){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+name+" attribute.");return null}mergedGeometry.setAttribute(name,mergedAttribute)}for(var name in morphAttributes){var numMorphTargets=morphAttributes[name][0].length;if(numMorphTargets===0)break;mergedGeometry.morphAttributes=mergedGeometry.morphAttributes||{};mergedGeometry.morphAttributes[name]=[];for(var i=0;i<numMorphTargets;++i){var morphAttributesToMerge=[];for(var j=0;j<morphAttributes[name].length;++j){morphAttributesToMerge.push(morphAttributes[name][j][i])}var mergedMorphAttribute=this.mergeBufferAttributes(morphAttributesToMerge);if(!mergedMorphAttribute){console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+name+" morphAttribute.");return null}mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)}}return mergedGeometry},mergeBufferAttributes:function(attributes){var TypedArray;var itemSize;var normalized;var arrayLength=0;for(var i=0;i<attributes.length;++i){var attribute=attributes[i];if(attribute.isInterleavedBufferAttribute){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.");return null}if(TypedArray===undefined)TypedArray=attribute.array.constructor;if(TypedArray!==attribute.array.constructor){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");return null}if(itemSize===undefined)itemSize=attribute.itemSize;if(itemSize!==attribute.itemSize){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");return null}if(normalized===undefined)normalized=attribute.normalized;if(normalized!==attribute.normalized){console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");return null}arrayLength+=attribute.array.length}var array=new TypedArray(arrayLength);var offset=0;for(var i=0;i<attributes.length;++i){array.set(attributes[i].array,offset);offset+=attributes[i].array.length}return new THREE.BufferAttribute(array,itemSize,normalized)},interleaveAttributes:function(attributes){var TypedArray;var arrayLength=0;var stride=0;for(var i=0,l=attributes.length;i<l;++i){var attribute=attributes[i];if(TypedArray===undefined)TypedArray=attribute.array.constructor;if(TypedArray!==attribute.array.constructor){console.error("AttributeBuffers of different types cannot be interleaved");return null}arrayLength+=attribute.array.length;stride+=attribute.itemSize}var interleavedBuffer=new THREE.InterleavedBuffer(new TypedArray(arrayLength),stride);var offset=0;var res=[];var getters=["getX","getY","getZ","getW"];var setters=["setX","setY","setZ","setW"];for(var j=0,l=attributes.length;j<l;j++){var attribute=attributes[j];var itemSize=attribute.itemSize;var count=attribute.count;var iba=new THREE.InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,attribute.normalized);res.push(iba);offset+=itemSize;for(var c=0;c<count;c++){for(var k=0;k<itemSize;k++){iba[setters[k]](c,attribute[getters[k]](c))}}}return res},estimateBytesUsed:function(geometry){var mem=0;for(var name in geometry.attributes){var attr=geometry.getAttribute(name);mem+=attr.count*attr.itemSize*attr.array.BYTES_PER_ELEMENT}var indices=geometry.getIndex();mem+=indices?indices.count*indices.itemSize*indices.array.BYTES_PER_ELEMENT:0;return mem},mergeVertices:function(geometry,tolerance=1e-4){tolerance=Math.max(tolerance,Number.EPSILON);var hashToIndex={};var indices=geometry.getIndex();var positions=geometry.getAttribute("position");var vertexCount=indices?indices.count:positions.count;var nextIndex=0;var attributeNames=Object.keys(geometry.attributes);var attrArrays={};var morphAttrsArrays={};var newIndices=[];var getters=["getX","getY","getZ","getW"];for(var i=0,l=attributeNames.length;i<l;i++){var name=attributeNames[i];attrArrays[name]=[];var morphAttr=geometry.morphAttributes[name];if(morphAttr){morphAttrsArrays[name]=new Array(morphAttr.length).fill().map((()=>[]))}}var decimalShift=Math.log10(1/tolerance);var shiftMultiplier=Math.pow(10,decimalShift);for(var i=0;i<vertexCount;i++){var index=indices?indices.getX(i):i;var hash="";for(var j=0,l=attributeNames.length;j<l;j++){var name=attributeNames[j];var attribute=geometry.getAttribute(name);var itemSize=attribute.itemSize;for(var k=0;k<itemSize;k++){hash+=`${~~(attribute[getters[k]](index)*shiftMultiplier)},`}}if(hash in hashToIndex){newIndices.push(hashToIndex[hash])}else{for(var j=0,l=attributeNames.length;j<l;j++){var name=attributeNames[j];var attribute=geometry.getAttribute(name);var morphAttr=geometry.morphAttributes[name];var itemSize=attribute.itemSize;var newarray=attrArrays[name];var newMorphArrays=morphAttrsArrays[name];for(var k=0;k<itemSize;k++){var getterFunc=getters[k];newarray.push(attribute[getterFunc](index));if(morphAttr){for(var m=0,ml=morphAttr.length;m<ml;m++){newMorphArrays[m].push(morphAttr[m][getterFunc](index))}}}}hashToIndex[hash]=nextIndex;newIndices.push(nextIndex);nextIndex++}}const result=geometry.clone();for(var i=0,l=attributeNames.length;i<l;i++){var name=attributeNames[i];var oldAttribute=geometry.getAttribute(name);var buffer=new oldAttribute.array.constructor(attrArrays[name]);var attribute=new THREE.BufferAttribute(buffer,oldAttribute.itemSize,oldAttribute.normalized);result.setAttribute(name,attribute);if(name in morphAttrsArrays){for(var j=0;j<morphAttrsArrays[name].length;j++){var oldMorphAttribute=geometry.morphAttributes[name][j];var buffer=new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);var morphAttribute=new THREE.BufferAttribute(buffer,oldMorphAttribute.itemSize,oldMorphAttribute.normalized);result.morphAttributes[name][j]=morphAttribute}}}result.setIndex(newIndices);return result},toTrianglesDrawMode:function(geometry,drawMode){if(drawMode===THREE.TrianglesDrawMode){console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");return geometry}if(drawMode===THREE.TriangleFanDrawMode||drawMode===THREE.TriangleStripDrawMode){var index=geometry.getIndex();if(index===null){var indices=[];var position=geometry.getAttribute("position");if(position!==undefined){for(var i=0;i<position.count;i++){indices.push(i)}geometry.setIndex(indices);index=geometry.getIndex()}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");return geometry}}var numberOfTriangles=index.count-2;var newIndices=[];if(drawMode===THREE.TriangleFanDrawMode){for(var i=1;i<=numberOfTriangles;i++){newIndices.push(index.getX(0));newIndices.push(index.getX(i));newIndices.push(index.getX(i+1))}}else{for(var i=0;i<numberOfTriangles;i++){if(i%2===0){newIndices.push(index.getX(i));newIndices.push(index.getX(i+1));newIndices.push(index.getX(i+2))}else{newIndices.push(index.getX(i+2));newIndices.push(index.getX(i+1));newIndices.push(index.getX(i))}}}if(newIndices.length/3!==numberOfTriangles){console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.")}var newGeometry=geometry.clone();newGeometry.setIndex(newIndices);newGeometry.clearGroups();return newGeometry}else{console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",drawMode);return geometry}}};AWater={AOcean:{DefaultData:{},Materials:{FFTWaves:{},Ocean:{}},Renderers:{},LUTlibraries:{}}};AWater.AOcean.Materials.FFTWaves.noiseShaderMaterialData={uniforms:{offset:{type:"f",value:1}},fragmentShader:["precision highp float;","uniform float offset;","//From http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/","float rand(float x){","float a = 12.9898;","float b = 78.233;","float c = 43758.5453;","float dt= dot(vec2(x, x) ,vec2(a,b));","float sn= mod(dt,3.14);","return fract(sin(sn) * c);","}","void main(){","vec2 uv = gl_FragCoord.xy / resolution.xy;","gl_FragColor = vec4(vec3(rand((resolution.x * (uv.x + uv.y * resolution.y)) * offset)), 1.0);","}"].join("\n")};AWater.AOcean.Materials.FFTWaves.h0ShaderMaterialData={uniforms:{N:{type:"f",value:256},L:{type:"f",value:1e3},A:{type:"f",value:20},L_:{type:"f",value:0},w:{type:"v2",value:new THREE.Vector2(1,0)}},fragmentShader:["precision highp float;","//With a lot of help from https://youtu.be/i0BPrGuOdPo","uniform float N; //256.0","uniform float L; //1000.0","uniform float A; //20","uniform vec2 w;//(1,0)","uniform float L_; //Windspeed squared over the gravitational acceleration","const float g = 9.80665;","const float pi = 3.141592653589793238462643383279502884197169;","const float piTimes2 = 6.283185307179586476925286766559005768394338798750211641949;","const float oneOverSqrtOf2 = 0.707106781186547524400844362104849039284835937688474036588;","//Box-Muller Method","vec4 gaussRand(vec2 uv){","vec2 texCoord = vec2(uv.xy);","float noise00 = clamp(texture2D(textureNoise1, texCoord).r + 0.00001, 0.0, 1.0);","float noise01 = clamp(texture2D(textureNoise2, texCoord).r + 0.00001, 0.0, 1.0);","float noise02 = clamp(texture2D(textureNoise3, texCoord).r + 0.00001, 0.0, 1.0);","float noise03 = clamp(texture2D(textureNoise4, texCoord).r + 0.00001, 0.0, 1.0);","float u0 = piTimes2 * noise00;","float v0 = sqrt(-2.0 * log(noise01));","float u1 = piTimes2 * noise02;","float v1 = sqrt(-2.0 * log(noise03));","return vec4(v0 * cos(u0), v0 * sin(u0), v1 * cos(u1), v1 * sin(u1));","}","void main(){","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec2 x = uv.xy * N;","vec2 k = vec2(piTimes2 / L) * x;","float magK = length(k);","if (magK < 0.0001) magK = 0.0001;","float magSq = magK * magK;","float L_ = 26.0 * 26.0 / 9.80665;","float h0_coeficient = sqrt(A / (magSq * magSq)) * exp(-1.0/(magSq * L_ * L_)) * exp(-magSq * pow(L / 2000.0, 2.0)) / sqrt(2.0);","//sqrt(Ph(k) / sqrt(2))","float h0_k = clamp(h0_coeficient * pow(dot(normalize(k), normalize(w)), 2.0), 0.0, 1000000.0);","//sqrt(Ph(-k) / sqrt(2))","float h0_minus_k = clamp(h0_coeficient * pow(dot(normalize(-k), normalize(w)), 2.0), 0.0, 1000000.0);","vec4 gaussianRandomNumber = gaussRand(uv);","gl_FragColor =vec4(gaussianRandomNumber.xy * h0_k, gaussianRandomNumber.zw * h0_minus_k);","}"].join("\n")};AWater.AOcean.Materials.FFTWaves.hkShaderMaterialData={uniforms:{textureH0:{type:"t",value:null},N:{type:"f",value:256},L:{type:"f",value:1e3},uTime:{type:"f",value:0}},fragmentShader:function(isXAxis=false,isYAxis=false){let originalGLSL=["precision highp float;","//With a lot of help from https://youtu.be/i0BPrGuOdPo","uniform sampler2D textureH0;","uniform float L; //1000.0","uniform float N; //256.0","uniform float uTime; //0.0","const float g = 9.80665;","const float piTimes2 = 6.283185307179586476925286766559005768394338798750211641949;","const float pi = 3.141592653589793238462643383279502884197169;","vec2 cMult(vec2 a, vec2 b){","return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);","}","vec2 cAdd(vec2 a, vec2 b){","return vec2(a.x + b.x, a.y + b.y);","}","vec2 conjugate(vec2 a){","return vec2(a.x, -1.0 * a.y);","}","void main(){","vec2 uv = gl_FragCoord.xy / resolution.xy;","vec2 x = uv.xy * N;","vec2 k = vec2(piTimes2 / L) * x;","float magK = length(k);","if (magK < 0.0001) magK = 0.0001;","float w = sqrt(g * magK);","vec4 tilda_h0 = texture2D(textureH0, uv.xy);","vec2 tilda_h0_k = tilda_h0.rg;","vec2 tilda_h0_minus_k_conj = conjugate(tilda_h0.ba);","float cosOfWT = cos(w * uTime);","float sinOfWT = sin(w * uTime);","//Euler Formula","vec2 expIwt = vec2(cosOfWT, sinOfWT);","vec2 expIwtConj = vec2(cosOfWT, -sinOfWT);","//dy","vec2 hk_tilda = cAdd(cMult(tilda_h0_k, expIwt), cMult(tilda_h0_minus_k_conj, expIwtConj));","#if($isXAxis)","vec2 dx = vec2(0.0, -k.x / magK);","hk_tilda = cMult(dx, hk_tilda);","#elif(!$isXAxis && !$isYAxis)","vec2 dy = vec2(0.0, -k.y / magK);","hk_tilda = cMult(dy, hk_tilda);","#endif","gl_FragColor = vec4(hk_tilda, 0.0, 1.0);","}"];let updatedLines=[];for(let i=0,numLines=originalGLSL.length;i<numLines;++i){let updatedGLSL=originalGLSL[i].replace(/\$isXAxis/g,isXAxis?"1":"0");updatedGLSL=updatedGLSL.replace(/\$isYAxis/g,isYAxis?"1":"0");updatedLines.push(updatedGLSL)}return updatedLines.join("\n")}};AWater.AOcean.Materials.FFTWaves.heightMapShaderData={uniforms:{pingpongTexture:{type:"t",value:null},oneOverNSquared:{type:"f",value:1}},fragmentShader:["precision highp float;","//With a lot of help from https://youtu.be/8kgpxtggFog","uniform sampler2D pingpongTexture;","uniform float oneOverNSquared;","//We might want to do this in the vertex shader rather then","//running through another shader pass for this.","void main(){","vec2 uv = vWorldPosition.xy;","//float h = texture2D(pingpongTexture, position).r;","//gl_FragColor = vec4(vec3(h * oneOverNSquared), 1.0);","gl_FragColor = vec4(texture2D(pingpongTexture, position).r, 0.0, 0.0, 1.0);","}"].join("\n")};AWater.AOcean.Materials.FFTWaves.computeTwiddleIndices=function(N,renderer){let twiddleTexture=[];let indices=[];let textureWidth=Math.ceil(Math.log(N)/Math.log(2));let textureHeight=N;for(let y=0;y<textureHeight;++y){let binary=y.toString(2).split("");for(let i=binary.length;i<textureWidth;++i){binary=["0",...binary]}binary.reverse();let bitReversedInteger=parseInt(binary.join(""),2);indices.push(bitReversedInteger)}for(let x=0;x<textureWidth;++x){twiddleTexture.push([]);for(let y=0;y<textureHeight;++y){twiddleTexture[x].push([0,0,0,0])}}let butterflySpan=1;let nextButterflySpan=butterflySpan*2;let twoPiOverN=2*Math.PI/N;for(let y=0;y<textureHeight;++y){let k=y*N/nextButterflySpan%N;let twiddle=[Math.cos(twoPiOverN*k),Math.sin(twoPiOverN*k)];if(y%nextButterflySpan<butterflySpan){twiddleTexture[0][y][0]=twiddle[0];twiddleTexture[0][y][1]=twiddle[1];twiddleTexture[0][y][2]=indices[y]/N;twiddleTexture[0][y][3]=indices[y+1]/N}else{twiddleTexture[0][y][0]=twiddle[0];twiddleTexture[0][y][1]=twiddle[1];twiddleTexture[0][y][2]=indices[y-1]/N;twiddleTexture[0][y][3]=indices[y]/N}}butterflySpan=nextButterflySpan;for(let x=1;x<textureWidth;++x){nextButterflySpan*=2;for(let y=0;y<textureHeight;++y){let k=y*N/nextButterflySpan%N;let twiddle=[Math.cos(twoPiOverN*k),Math.sin(twoPiOverN*k)];if(y%nextButterflySpan<butterflySpan){twiddleTexture[x][y][0]=twiddle[0];twiddleTexture[x][y][1]=twiddle[1];twiddleTexture[x][y][2]=y/N;twiddleTexture[x][y][3]=(y+butterflySpan)/N}else{twiddleTexture[x][y][0]=twiddle[0];twiddleTexture[x][y][1]=twiddle[1];twiddleTexture[x][y][2]=(y-butterflySpan)/N;twiddleTexture[x][y][3]=y/N}}butterflySpan=nextButterflySpan}let data=[];let bandWidth=Math.round(textureHeight/textureWidth);for(let y=0;y<textureHeight;y++){for(let x=0;x<textureWidth;x++){for(let i=0;i<4;++i){data.push(twiddleTexture[x][y][0]);data.push(twiddleTexture[x][y][1]);data.push(twiddleTexture[x][y][2]);data.push(twiddleTexture[x][y][3])}}}let actualTextureWidth=4*textureWidth;let dataTexture=new THREE.DataTexture(new Float32Array(data),actualTextureWidth,textureHeight,THREE.RGBAFormat,/(iPad|iPhone|iPod)/g.test(navigator.userAgent)?THREE.HalfFloatType:THREE.FloatType,THREE.ClampToEdgeWrapping,THREE.ClampToEdgeWrapping,THREE.NearestFilter,THREE.NearestFilter);dataTexture.needsUpdate=true;return dataTexture};AWater.AOcean.Materials.FFTWaves.butterflyTextureData={uniforms:{twiddleTexture:{type:"t",value:null},stageFraction:{type:"f",value:0},direction:{type:"i",value:1}},fragmentShader:function(pingpong_id,injectVariable=false){let glsl=["precision highp float;","varying vec3 vWorldPosition;","//With a lot of help from https://youtu.be/i0BPrGuOdPo","uniform sampler2D twiddleTexture;","uniform float stageFraction;","uniform int direction;","const float pi = 3.141592653589793238462643383279502884197169;","vec2 cMult(vec2 a, vec2 b){","return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);","}","vec2 cAdd(vec2 a, vec2 b){","return vec2(a.x + b.x, a.y + b.y);","}","vec4 horizontalButterflies(vec2 position){","vec4 data = texture2D(twiddleTexture, vec2(stageFraction, position.x));",`vec2 p = texture2D(pingpong_${pingpong_id}, vec2(data.z, position.y)).rg;`,`vec2 q = texture2D(pingpong_${pingpong_id}, vec2(data.w, position.y)).rg;`,"vec2 w = vec2(data.x, data.y);","vec2 H = cAdd(p, cMult(w, q));","return vec4(H, 0.0, 1.0);","}","vec4 verticalButterflies(vec2 position){","vec4 data = texture2D(twiddleTexture, vec2(stageFraction, position.y));",`vec2 p = texture2D(pingpong_${pingpong_id}, vec2(position.x, data.z)).rg;`,`vec2 q = texture2D(pingpong_${pingpong_id}, vec2(position.x, data.w)).rg;`,"vec2 w = vec2(data.x, data.y);","vec2 H = cAdd(p, cMult(w, q));","return vec4(H, 0.0, 1.0);","}","void main(){","vec2 position = gl_FragCoord.xy / resolution.xy;","vec4 result;","//If horizontal butterfly","//(Note: We should probably pull this into another shader later.)","if(direction == 0){","\t\tresult = horizontalButterflies(position);","}","\telse if(direction == 1){","\t\tresult = verticalButterflies(position);","}","gl_FragColor = result;","}"];if(injectVariable){glsl=[`uniform sampler2D pingpong_${pingpong_id};`,...glsl]}return glsl.join("\n")}};AWater.AOcean.Materials.FFTWaves.amplitudeFilterShaderMaterial={uniforms:{frequencyRadiusStart:{type:"f",value:0},maxBandwidthStart:{type:"f",value:3e7}},fragmentShader:function(){return["precision highp float;","varying vec3 vWorldPosition;","uniform float frequencyRadiusStart;","uniform float maxBandwidthStart;","void main(){","vec2 position = gl_FragCoord.xy / resolution.xy;","vec2 hkTexel = texture2D(textureHk, position).rg;","//Low has a radius greater than 0.05 and a band limit of 10000","//Low medium has a radius greater than 0.01 and a band limit of 750000","//medium has a radius greater than 0.002 and a band limit of 10000000.0","//medium high as a radius greater than 0.0014 and a band limit of 30000000.0","//This could use fading... but for now, we don't need fading, we need this to work","//So our filters are hard.","float redChannelOut = 0.0;","float greenChannelOut = 0.0;","float radiusOfFrequency = sqrt(position.x * position.x + position.y * position.y);","bool frequencyInRange = radiusOfFrequency > frequencyRadiusStart;","if(abs(hkTexel.r) < maxBandwidthStart && frequencyInRange){","redChannelOut = hkTexel.r;","}","if(abs(hkTexel.g) < maxBandwidthStart && frequencyInRange){","greenChannelOut = hkTexel.g;","}","gl_FragColor = vec4(redChannelOut, greenChannelOut, 0.0, 1.0);","}"].join("\n")}};AWater.AOcean.Materials.FFTWaves.waveComposerShaderMaterial={uniforms:function(numberOfWaveComponents){return{xWavetextures:{value:new Array(numberOfWaveComponents)},yWavetextures:{value:new Array(numberOfWaveComponents)},zWavetextures:{value:new Array(numberOfWaveComponents)},N:{type:"f",value:0}}},fragmentShader:function(numberOfWaveComponents){let originalGLSL=["varying vec3 vWorldPosition;","uniform sampler2D xWavetextures[$total_offsets];","uniform sampler2D yWavetextures[$total_offsets];","uniform sampler2D zWavetextures[$total_offsets];","uniform float N;","float fModulo1(float a){","return (a - floor(a));","}","void main(){","vec2 position = gl_FragCoord.xy / resolution.xy;","float sizeExpansion = (resolution.x + 1.0) / resolution.x; //Expand by exactly one pixel","vec2 uv = sizeExpansion * position;","vec2 wrappedUV = vec2(fModulo1(uv.x), fModulo1(uv.y));","vec3 combinedWaveHeight = vec3(0.0);","//Interpolations","float waveHeight_x;","float waveHeight_y;","float waveHeight_z;","$unrolled_wave_composer","// for(int i = 0; i < numberOfWaveTextures; i++){","//   float waveHeight_x = texture2D(xWavetextures[i], wrappedUV).x;","//   float waveHeight_y = texture2D(yWavetextures[i], wrappedUV).x;","//   float waveHeight_z = texture2D(zWavetextures[i], wrappedUV).x;","//   combinedWaveHeight += vec3(waveHeight_x, waveHeight_y, waveHeight_z);","//   totalOffsets += 1.0;","// }","gl_FragColor = vec4(combinedWaveHeight / ($total_offsets_float * N * N), 1.0);","}"];let numberOfWaveComponentsGLSL="";for(let i=0;i<numberOfWaveComponents;++i){numberOfWaveComponentsGLSL+=`waveHeight_x = texture2D(xWavetextures[${i}], wrappedUV).x;\n`;numberOfWaveComponentsGLSL+=`waveHeight_y = texture2D(yWavetextures[${i}], wrappedUV).x;\n`;numberOfWaveComponentsGLSL+=`waveHeight_z = texture2D(zWavetextures[${i}], wrappedUV).x;\n`;numberOfWaveComponentsGLSL+="combinedWaveHeight += vec3(waveHeight_x, waveHeight_y, waveHeight_z);\n"}let updatedLines=[];for(let i=0,numLines=originalGLSL.length;i<numLines;++i){let updatedCode=originalGLSL[i];updatedCode=updatedCode.replace(/\$unrolled_wave_composer/g,numberOfWaveComponentsGLSL);updatedCode=updatedCode.replace(/\$total_offsets_float/g,numberOfWaveComponents+".0");updatedCode=updatedCode.replace(/\$total_offsets/g,numberOfWaveComponents);updatedLines.push(updatedCode)}return updatedLines.join("\n")}};AWater.AOcean.Materials.FFTWaves.waveHeightShaderMaterialData={uniforms:{combinedWaveHeights:{type:"t",value:null},N:{type:"f",value:0},waveHeightMultiplier:{type:"f",value:1}},fragmentShader:["precision highp float;","uniform sampler2D combinedWaveHeights;","uniform float N;","uniform float waveHeightMultiplier;","void main(){","vec2 uv = gl_FragCoord.xy / resolution.xy;","float outputputColor = waveHeightMultiplier * texture2D(combinedWaveHeights, uv).xyz / (N * N);","gl_FragColor = vec4(vec3(outputColor), 1.0);","}"].join("\n")};AWater.AOcean.Materials.Ocean.positionPassMaterial={uniforms:{worldMatrix:{type:"mat4",value:new THREE.Matrix4},viewMatrix:{type:"mat4",value:new THREE.Matrix4}},fragmentShader:["varying vec3 vWorldPosition;","void main(){","//Check if we are above or below the water to see what kind of fog is applied","gl_FragColor = vec4(vWorldPosition, 1.0);","}"].join("\n"),vertexShader:["precision highp float;","//attribute vec3 baseDepth;","varying vec3 vWorldPosition;","uniform mat4 worldMatrix;","void main() {","vWorldPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;","gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n")};AWater.AOcean.LUTlibraries.OceanHeightBandLibrary=function(parentOceanGrid){let renderer=parentOceanGrid.renderer;let data=parentOceanGrid.data;this.numLevels=parentOceanGrid.numberOfOceanHeightBands;if(!renderer.capabilities.isWebGL2&&!renderer.extensions.get("OES_texture_float_linear")){console.error("No linear interpolation of OES textures allowed.");return false}this.staticGPUComputer;this.hkRenderer;this.noiseVar1;this.noiseVar2;this.noiseVar3;this.noiseVar4;this.noiseTexture1;this.noiseTexture2;this.noiseTexture3;this.noiseTexture4;this.h0Var;this.h0Texture;this.hkXVar;this.hkYVar;this.hkZVar;this.hkXTexture;this.hkYTexture;this.hkZTexture;this.textureWidth=data.patch_data_size;this.textureHeight=data.patch_data_size;this.filteredHkXTextures=new Array(this.numLevels);this.filteredHkYTextures=new Array(this.numLevels);this.filteredHkZTextures=new Array(this.numLevels);this.wavesXFilteredByAmplitude=new Array(this.numLevels);this.wavesYFilteredByAmplitude=new Array(this.numLevels);this.wavesZFilteredByAmplitude=new Array(this.numLevels);this.N=data.number_of_octaves;this.L=data.patch_size;let windVelocity=new THREE.Vector2(data.wind_velocity.x,data.wind_velocity.y);this.L_=windVelocity.dot(windVelocity)*data.patch_data_size;this.w=windVelocity.clone().normalize();this.renderer=renderer;document.body.appendChild(renderer.domElement);this.twiddleTexture=AWater.AOcean.Materials.FFTWaves.computeTwiddleIndices(this.N,renderer);let maxWaveAmplitutude=.54*this.L_;this.staticGPUComputer=new THREE.GPUComputationRenderer(this.textureWidth,this.textureHeight,this.renderer);this.hkRenderer=new THREE.GPUComputationRenderer(this.textureWidth,this.textureHeight,this.renderer);let hkRenderer=this.hkRenderer;const materials=AWater.AOcean.Materials.FFTWaves;let offset=this.textureWidth*this.textureHeight;let staticGPUCompute=this.staticGPUComputer;this.noiseTexture1=staticGPUCompute.createTexture();this.noiseVar1=staticGPUCompute.addVariable("textureNoise1",materials.noiseShaderMaterialData.fragmentShader,this.noiseTexture1);let noiseVar1=this.noiseVar1;noiseVar1.minFilter=THREE.ClosestFilter;noiseVar1.magFilter=THREE.ClosestFilter;staticGPUCompute.setVariableDependencies(noiseVar1,[]);noiseVar1.material.uniforms=JSON.parse(JSON.stringify(materials.noiseShaderMaterialData.uniforms));noiseVar1.material.uniforms.offset.value=1;this.noiseTexture2=staticGPUCompute.createTexture();this.noiseVar2=staticGPUCompute.addVariable("textureNoise2",materials.noiseShaderMaterialData.fragmentShader,this.noiseTexture2);let noiseVar2=this.noiseVar2;staticGPUCompute.setVariableDependencies(noiseVar2,[]);noiseVar2.material.uniforms=JSON.parse(JSON.stringify(materials.noiseShaderMaterialData.uniforms));noiseVar2.material.uniforms.offset.value=noiseVar1.material.uniforms.offset.value+this.textureWidth*this.textureHeight;noiseVar2.minFilter=THREE.ClosestFilter;noiseVar2.magFilter=THREE.ClosestFilter;this.noiseTexture3=staticGPUCompute.createTexture();this.noiseVar3=staticGPUCompute.addVariable("textureNoise3",materials.noiseShaderMaterialData.fragmentShader,this.noiseTexture3);let noiseVar3=this.noiseVar3;staticGPUCompute.setVariableDependencies(noiseVar3,[]);noiseVar3.material.uniforms=JSON.parse(JSON.stringify(materials.noiseShaderMaterialData.uniforms));noiseVar3.material.uniforms.offset.value=noiseVar2.material.uniforms.offset.value+this.textureWidth*this.textureHeight;noiseVar3.minFilter=THREE.ClosestFilter;noiseVar3.magFilter=THREE.ClosestFilter;this.noiseTexture4=staticGPUCompute.createTexture();this.noiseVar4=staticGPUCompute.addVariable("textureNoise4",materials.noiseShaderMaterialData.fragmentShader,this.noiseTexture4);let noiseVar4=this.noiseVar4;staticGPUCompute.setVariableDependencies(noiseVar4,[]);noiseVar4.material.uniforms=JSON.parse(JSON.stringify(materials.noiseShaderMaterialData.uniforms));noiseVar4.material.uniforms.offset.value=noiseVar3.material.uniforms.offset.value+this.textureWidth*this.textureHeight;noiseVar4.minFilter=THREE.ClosestFilter;noiseVar4.magFilter=THREE.ClosestFilter;this.h0Texture=staticGPUCompute.createTexture();this.h0Var=staticGPUCompute.addVariable("textureH0",materials.h0ShaderMaterialData.fragmentShader,this.h0Texture);this.h0Var.minFilter=THREE.ClosestFilter;this.h0Var.magFilter=THREE.ClosestFilter;let h0Var=this.h0Var;staticGPUCompute.setVariableDependencies(h0Var,[noiseVar1,noiseVar2,noiseVar3,noiseVar4]);h0Var.material.uniforms={...h0Var.material.uniforms,...JSON.parse(JSON.stringify(materials.h0ShaderMaterialData.uniforms))};h0Var.material.uniforms.N.value=this.N;h0Var.material.uniforms.L.value=this.L;h0Var.material.uniforms.A.value=maxWaveAmplitutude;h0Var.material.uniforms.L_.value=this.L_;h0Var.material.uniforms.w.value=this.w.clone();let error1=staticGPUCompute.init();if(error1!==null){console.error(`Static GPU Compute Renderer: ${error1}`)}staticGPUCompute.compute();staticGPUCompute.compute();this.hkYTexture=hkRenderer.createTexture();this.hkYVar=hkRenderer.addVariable("textureHk",materials.hkShaderMaterialData.fragmentShader(false,true),this.hkYTexture);let hkYVar=this.hkYVar;this.hkYVar.minFilter=THREE.ClosestFilter;this.hkYVar.magFilter=THREE.ClosestFilter;hkRenderer.setVariableDependencies(hkYVar,[]);hkYVar.material.uniforms=JSON.parse(JSON.stringify(materials.hkShaderMaterialData.uniforms));hkYVar.material.uniforms.textureH0.value=this.staticGPUComputer.getCurrentRenderTarget(h0Var).texture;hkYVar.material.uniforms.L.value=1e3;hkYVar.material.uniforms.uTime.value=500;hkYVar.material.uniforms.N.value=this.N;this.hkXTexture=hkRenderer.createTexture();this.hkXVar=hkRenderer.addVariable("textureHk",materials.hkShaderMaterialData.fragmentShader(true,false),this.hkXTexture);let hkXVar=this.hkXVar;this.hkXVar.minFilter=THREE.ClosestFilter;this.hkXVar.magFilter=THREE.ClosestFilter;hkRenderer.setVariableDependencies(hkXVar,[]);hkXVar.material.uniforms=JSON.parse(JSON.stringify(materials.hkShaderMaterialData.uniforms));hkXVar.material.uniforms.textureH0.value=this.staticGPUComputer.getCurrentRenderTarget(h0Var).texture;hkXVar.material.uniforms.L.value=1e3;hkXVar.material.uniforms.uTime.value=500;hkXVar.material.uniforms.N.value=this.N;this.hkZTexture=hkRenderer.createTexture();this.hkZVar=hkRenderer.addVariable("textureHk",materials.hkShaderMaterialData.fragmentShader(false,false),this.hkZTexture);let hkZVar=this.hkZVar;this.hkZVar.minFilter=THREE.ClosestFilter;this.hkZVar.magFilter=THREE.ClosestFilter;hkRenderer.setVariableDependencies(hkZVar,[]);hkZVar.material.uniforms=JSON.parse(JSON.stringify(materials.hkShaderMaterialData.uniforms));hkZVar.material.uniforms.textureH0.value=this.staticGPUComputer.getCurrentRenderTarget(h0Var).texture;hkZVar.material.uniforms.L.value=1e3;hkZVar.material.uniforms.uTime.value=500;hkZVar.material.uniforms.N.value=this.N;this.hkXBandTextures=[];this.hkXBandVars=[];this.hkYBandTextures=[];this.hkYBandVars=[];this.hkZBandTextures=[];this.hkZBandVars=[];let frequencyRadaii=[.05,.01,.002,.0014,0];let bandFrequencyLimits=[1e4,75e4,1e7,3e7,1e8];for(let i=0;i<this.numLevels;i++){this.hkYBandTextures.push(hkRenderer.createTexture());this.hkYBandVars.push(hkRenderer.addVariable(`textureHkYBand_${i}`,materials.amplitudeFilterShaderMaterial.fragmentShader(false,true),this.hkYBandTextures[i]));hkRenderer.setVariableDependencies(this.hkYBandVars[i],[hkYVar]);this.hkYBandVars[i].material.uniforms=JSON.parse(JSON.stringify(materials.amplitudeFilterShaderMaterial.uniforms));this.hkYBandVars[i].material.uniforms.frequencyRadiusStart.value=frequencyRadaii[i];this.hkYBandVars[i].material.uniforms.maxBandwidthStart.value=bandFrequencyLimits[i];this.hkYBandVars[i].minFilter=THREE.ClosestFilter;this.hkYBandVars[i].magFilter=THREE.ClosestFilter;this.hkXBandTextures.push(hkRenderer.createTexture());this.hkXBandVars.push(hkRenderer.addVariable(`textureHkXBand_${i}`,materials.amplitudeFilterShaderMaterial.fragmentShader(true,false),this.hkXBandTextures[i]));hkRenderer.setVariableDependencies(this.hkXBandVars[i],[hkXVar]);this.hkXBandVars[i].material.uniforms=JSON.parse(JSON.stringify(materials.amplitudeFilterShaderMaterial.uniforms));this.hkXBandVars[i].material.uniforms.frequencyRadiusStart.value=frequencyRadaii[i];this.hkXBandVars[i].material.uniforms.maxBandwidthStart.value=bandFrequencyLimits[i];this.hkXBandVars[i].minFilter=THREE.ClosestFilter;this.hkXBandVars[i].magFilter=THREE.ClosestFilter;this.hkZBandTextures.push(hkRenderer.createTexture());this.hkZBandVars.push(hkRenderer.addVariable(`textureHkZBand_${i}`,materials.amplitudeFilterShaderMaterial.fragmentShader(false,false),this.hkZBandTextures[i]));hkRenderer.setVariableDependencies(this.hkZBandVars[i],[hkZVar]);this.hkZBandVars[i].material.uniforms=JSON.parse(JSON.stringify(materials.amplitudeFilterShaderMaterial.uniforms));this.hkZBandVars[i].material.uniforms.frequencyRadiusStart.value=frequencyRadaii[i];this.hkZBandVars[i].material.uniforms.maxBandwidthStart.value=bandFrequencyLimits[i];this.hkZBandVars[i].minFilter=THREE.ClosestFilter;this.hkZBandVars[i].magFilter=THREE.ClosestFilter}let error3=hkRenderer.init();if(error3!==null){console.error(`Dynamic GPU Compute Renderer: ${error3}`)}hkRenderer.compute();this.butterflyRenderers=[];this.butterflyTextureVarHolder=[];this.finalButterflyTextureVars=[];for(let dimension=0;dimension<3;dimension++){this.butterflyRenderers.push([]);this.butterflyTextureVarHolder.push([]);this.finalButterflyTextureVars.push([]);for(let i=0;i<this.numLevels;i++){this.butterflyRenderers[dimension].push(new THREE.GPUComputationRenderer(this.textureWidth,this.textureHeight,this.renderer));let butterflyRenderer=this.butterflyRenderers[dimension][i];let butterflyTextureVars=[];let numPingPongIterations=Math.ceil(Math.log(this.N)/Math.log(2));let butterflyTextureInit=this.hkRenderer.createTexture();butterflyTextureVars.push(butterflyRenderer.addVariable(`pingpong_0`,materials.butterflyTextureData.fragmentShader("hk_texture",true),butterflyTextureInit));butterflyRenderer.setVariableDependencies(butterflyTextureVars[0],[]);butterflyTextureVars[0].material.uniforms=JSON.parse(JSON.stringify(materials.butterflyTextureData.uniforms));butterflyTextureVars[0].material.uniforms.pingpong_hk_texture={};butterflyTextureVars[0].material.uniforms.pingpong_hk_texture.type="t";butterflyTextureVars[0].material.uniforms.pingpong_hk_texture.value=null;butterflyTextureVars[0].material.uniforms.direction.value=0;butterflyTextureVars[0].material.uniforms.stageFraction.value=0;butterflyTextureVars[0].material.uniforms.twiddleTexture.value=this.twiddleTexture;for(let i=1;i<numPingPongIterations;i++){let butterFlyTexture=butterflyRenderer.createTexture();butterflyTextureVars.push(butterflyRenderer.addVariable(`pingpong_${i}`,materials.butterflyTextureData.fragmentShader(i-1),butterFlyTexture));butterflyRenderer.setVariableDependencies(butterflyTextureVars[i],[butterflyTextureVars[i-1]]);butterflyTextureVars[i].material.uniforms=JSON.parse(JSON.stringify(materials.butterflyTextureData.uniforms));butterflyTextureVars[i].material.uniforms.direction.value=0;butterflyTextureVars[i].material.uniforms.stageFraction.value=i/(numPingPongIterations-1);butterflyTextureVars[i].material.uniforms.twiddleTexture.value=this.twiddleTexture;butterflyTextureVars[i].minFilter=THREE.NearestFilter;butterflyTextureVars[i].magFilter=THREE.NearestFilter}let numPingPongIterationsTimes2=numPingPongIterations*2;for(let i=numPingPongIterations;i<numPingPongIterationsTimes2;i++){let butterFlyTexture=butterflyRenderer.createTexture();butterflyTextureVars.push(butterflyRenderer.addVariable(`pingpong_${i}`,materials.butterflyTextureData.fragmentShader(i-1),butterFlyTexture));butterflyRenderer.setVariableDependencies(butterflyTextureVars[i],[butterflyTextureVars[i-1]]);butterflyTextureVars[i].material.uniforms=JSON.parse(JSON.stringify(materials.butterflyTextureData.uniforms));butterflyTextureVars[i].material.uniforms.direction.value=1;butterflyTextureVars[i].material.uniforms.stageFraction.value=(i-numPingPongIterations)/(numPingPongIterations-1);butterflyTextureVars[i].material.uniforms.twiddleTexture.value=this.twiddleTexture;butterflyTextureVars[i].minFilter=THREE.NearestFilter;butterflyTextureVars[i].magFilter=THREE.NearestFilter}this.finalButterflyTextureVars[dimension].push(butterflyTextureVars[numPingPongIterationsTimes2-1]);this.butterflyTextureVarHolder[dimension].push(butterflyTextureVars);let error4=butterflyRenderer.init();if(error4!==null){console.error(`Butterfly Texture Renderer: ${error4}`)}butterflyRenderer.compute()}}let self=this;this.tick=function(time,activeTextures){self.hkXVar.material.uniforms.uTime.value=time/1e3;self.hkYVar.material.uniforms.uTime.value=time/1e3;self.hkZVar.material.uniforms.uTime.value=time/1e3;self.hkRenderer.compute();for(let i=0;i<self.numLevels;++i){self.butterflyTextureVarHolder[0][i][0].material.uniforms.pingpong_hk_texture.value=self.hkRenderer.getCurrentRenderTarget(self.hkXBandVars[i]).texture;self.butterflyRenderers[0][i].compute();self.wavesXFilteredByAmplitude[i]=self.butterflyRenderers[0][i].getCurrentRenderTarget(self.finalButterflyTextureVars[0][i]).texture}for(let i=0;i<self.numLevels;++i){self.butterflyTextureVarHolder[1][i][0].material.uniforms.pingpong_hk_texture.value=self.hkRenderer.getCurrentRenderTarget(self.hkYBandVars[i]).texture;self.butterflyRenderers[1][i].compute();self.wavesYFilteredByAmplitude[i]=self.butterflyRenderers[1][i].getCurrentRenderTarget(self.finalButterflyTextureVars[1][i]).texture}for(let i=0;i<self.numLevels;++i){self.butterflyTextureVarHolder[2][i][0].material.uniforms.pingpong_hk_texture.value=self.hkRenderer.getCurrentRenderTarget(self.hkZBandVars[i]).texture;self.butterflyRenderers[2][i].compute();self.wavesZFilteredByAmplitude[i]=self.butterflyRenderers[2][i].getCurrentRenderTarget(self.finalButterflyTextureVars[2][i]).texture}}};AWater.AOcean.LUTlibraries.OceanHeightComposer=function(parentOceanGrid){let data=parentOceanGrid.data;this.renderer=parentOceanGrid.renderer;this.baseTextureWidth=data.patch_data_size;this.baseTextureHeight=data.patch_data_size;this.outputTextureWidth=this.baseTextureWidth;this.outputTextureHeight=this.baseTextureHeight;this.N=data.number_of_octaves;this.OceanMaterialHeightBandLibrary=parentOceanGrid.oceanHeightBandLibrary;this.numberOfWaveComponents=parentOceanGrid.numberOfOceanHeightBands;this.parentOceanGrid=parentOceanGrid;this.combinedWaveHeights;this.displacementMap;const materials=AWater.AOcean.Materials.FFTWaves;this.waveHeightComposerRenderer=new THREE.GPUComputationRenderer(this.baseTextureWidth,this.baseTextureHeight,this.renderer);this.waveFoamRenderer=new THREE.GPUComputationRenderer(this.baseTextureWidth,this.baseTextureHeight,this.renderer);this.waveHeightComposerTexture=this.waveHeightComposerRenderer.createTexture();this.waveHeightComposerVar=this.waveHeightComposerRenderer.addVariable("waveHeightTexture",materials.waveComposerShaderMaterial.fragmentShader(this.numberOfWaveComponents),this.waveHeightComposerTexture);let whcVar=this.waveHeightComposerVar;this.waveHeightComposerVar.material.uniforms.waveHeightMultiplier=data.wave_scale_multiple;this.waveHeightComposerVar.minFilter=THREE.LinearFilter;this.waveHeightComposerVar.magFilter=THREE.LinearFilter;this.waveHeightComposerVar.wrapS=THREE.RepeatWrapping;this.waveHeightComposerVar.wrapT=THREE.RepeatWrapping;this.waveHeightComposerRenderer.setVariableDependencies(whcVar,[]);whcVar.material.uniforms=materials.waveComposerShaderMaterial.uniforms(this.numberOfWaveComponents);whcVar.material.uniforms.N.value=this.N;let error5=this.waveHeightComposerRenderer.init();if(error5!==null){console.error(`Wave Height Composer Renderer: ${error5}`)}this.waveHeightComposerRenderer.compute();let self=this;this.tick=function(){for(let i=0;i<this.numberOfWaveComponents;++i){self.waveHeightComposerVar.material.uniforms.xWavetextures.value[i]=this.OceanMaterialHeightBandLibrary.wavesXFilteredByAmplitude[i];self.waveHeightComposerVar.material.uniforms.yWavetextures.value[i]=this.OceanMaterialHeightBandLibrary.wavesYFilteredByAmplitude[i];self.waveHeightComposerVar.material.uniforms.zWavetextures.value[i]=this.OceanMaterialHeightBandLibrary.wavesZFilteredByAmplitude[i]}self.waveHeightComposerRenderer.compute();this.displacementMap=self.waveHeightComposerRenderer.getCurrentRenderTarget(self.waveHeightComposerVar).texture}};AWater.AOcean.Materials.Ocean.waterMaterial={uniforms:{displacementMap:{type:"t",value:null},smallNormalMap:{type:"t",value:null},largeNormalMap:{type:"t",value:null},smallNormalMapVelocity:{type:"vec2",value:new THREE.Vector2},largeNormalMapVelocity:{type:"vec2",value:new THREE.Vector2},isBelowWater:{type:"i",value:0},reflectionCubeMap:{value:null},refractionCubeMap:{value:null},depthCubeMap:{value:null},matrixWorld:{type:"mat4",value:new THREE.Matrix4},sizeOfOceanPatch:{type:"f",value:1},fogNear:{type:"f",value:null},fogFar:{type:"f",value:null},fogDensity:{type:"f",value:null},fogColor:{type:"v3",value:new THREE.Color},t:{type:"f",value:0},brightestDirectionalLight:{type:"vec3",value:new THREE.Vector3(1,1,1)},largeNormalMapStrength:{type:"f",value:.45},smallNormalMapStrength:{type:"f",value:.35},lightScatteringAmounts:{type:"vec3",value:new THREE.Vector3(88,108,112)},linearScatteringHeightOffset:{type:"f",value:10},linearScatteringTotalScatteringWaveHeight:{type:"f",value:20}},fragmentShader:["precision highp float;","varying float height;","varying vec3 vViewVector;","varying vec3 vWorldPosition;","varying vec4 colorMap;","varying vec2 vUv;","varying vec3 displacedNormal;","varying mat3 modelMatrixMat3;","//uniform vec3 cameraDirection;","uniform int isBelowWater;","uniform float sizeOfOceanPatch;","uniform float largeNormalMapStrength;","uniform float smallNormalMapStrength;","uniform sampler2D smallNormalMap;","uniform sampler2D largeNormalMap;","uniform samplerCube reflectionCubeMap;","uniform samplerCube refractionCubeMap;","uniform samplerCube depthCubeMap;","uniform vec2 smallNormalMapVelocity;","uniform vec2 largeNormalMapVelocity;","uniform vec3 brightestDirectionalLight;","uniform vec3 lightScatteringAmounts;","uniform float t;","//Fog variables","#include <fog_pars_fragment>","uniform vec4 directLightingColor;","//R0 For Schlick's Approximation","//With n1 = 1.33 and n0 = 1.05","const float r0 = 0.01968152171;","const vec3 inverseGamma = vec3(0.454545454545454545454545);","const vec3 gamma = vec3(2.2);","vec2 vec2Modulo(vec2 inputUV){","return (inputUV - floor(inputUV));","}","//From https://blog.selfshadow.com/publications/blending-in-detail/","vec3 combineNormals(vec3 normal1, vec3 normal2){","vec3 t = normal1.xyz * vec3(2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);","vec3 u = normal2.xyz * vec3(-2.0, -2.0, 2.0) + vec3(1.0,  1.0, -1.0);","vec3 r = t * dot(t, u) - u * t.z;","return (normalize(r) + vec3(1.0)) * 0.5;","}","//Including this because someone removed this in a future versio of THREE. Why?!","vec3 MyAESFilmicToneMapping(vec3 color) {","return clamp((color * (2.51 * color + 0.03)) / (color * (2.43 * color + 0.59) + 0.14), 0.0, 1.0);","}","void main(){","//Get the reflected and refracted information of the scene","vec2 cameraOffset = vec2(cameraPosition.x, -cameraPosition.z);","vec2 uvOffset = vec2Modulo(vUv + (cameraOffset / sizeOfOceanPatch));","vec2 smallNormalMapOffset = (vUv * 3.0) + ((cameraOffset + t * smallNormalMapVelocity) / (sizeOfOceanPatch / 3.0));","vec2 largeNormalMapOffset = (vUv * 5.0) + ((cameraOffset - t * largeNormalMapVelocity) / (sizeOfOceanPatch / 5.0));","vec3 smallNormalMap = texture2D(smallNormalMap, smallNormalMapOffset).xyz;","smallNormalMap = 2.0 * smallNormalMap - 1.0;","smallNormalMap.xy *= smallNormalMapStrength;","smallNormalMap = normalize(smallNormalMap);","smallNormalMap = (smallNormalMap + 1.0) * 0.5;","vec3 largeNormalMap = texture2D(largeNormalMap, largeNormalMapOffset).xyz;","largeNormalMap = 2.0 * largeNormalMap - 1.0;","largeNormalMap.xy *= largeNormalMapStrength;","largeNormalMap = normalize(largeNormalMap);","largeNormalMap = (largeNormalMap + 1.0) * 0.5;","vec3 combinedNormalMap = combineNormals(smallNormalMap, largeNormalMap);","vec3 normalizedDisplacedNormalMap = (normalize(displacedNormal.xyz) + vec3(1.0)) * 0.5;","combinedNormalMap = combineNormals(normalizedDisplacedNormalMap, combinedNormalMap);","combinedNormalMap = combinedNormalMap * 2.0 - vec3(1.0);","combinedNormalMap = normalize(modelMatrixMat3 * combinedNormalMap);","vec3 normalizedViewVector = normalize(vViewVector);","vec3 reflectedCoordinates = reflect(normalizedViewVector, combinedNormalMap);","vec3 refractedCoordinates = refract(normalizedViewVector, combinedNormalMap, 1.005 / 1.333);","vec3 reflectedLight = textureCube(reflectionCubeMap, reflectedCoordinates).rgb; //Reflection","vec3 refractedLight = textureCube(refractionCubeMap, refractedCoordinates).rgb; //Refraction","vec3 pointXYZ = textureCube(depthCubeMap, refractedCoordinates).rgb; //Scattering","float distanceToPoint = distance(pointXYZ, vWorldPosition);","vec3 normalizedTransmittancePercentColor = normalize(lightScatteringAmounts);","vec3 percentOfSourceLight = clamp(exp(-distanceToPoint / lightScatteringAmounts), 0.0, 1.0);","refractedLight = percentOfSourceLight * pow(refractedLight, gamma);","//Increasing brightness with height inspired by, https://80.lv/articles/tutorial-ocean-shader-with-gerstner-waves/","vec3 inscatterLight = pow(max(height, 0.0) * length(vec3(1.0) - percentOfSourceLight) * pow(normalizedTransmittancePercentColor, vec3(2.5))  * brightestDirectionalLight, gamma);","//Apply Schlick's approximation for the fresnel amount","//https://en.wikipedia.org/wiki/Schlick%27s_approximation","float oneMinusCosTheta = 1.0 - dot(combinedNormalMap, -normalizedViewVector);","float reflectedLightPercent = clamp(r0 + (1.0 -  r0) * pow(0.9 * oneMinusCosTheta, 5.0), 0.0, 1.0);","reflectedLight = pow(reflectedLight, gamma);","//Total light","vec3 totalLight = inscatterLight + mix(refractedLight, reflectedLight, reflectedLightPercent);","gl_FragColor = vec4(pow(MyAESFilmicToneMapping(totalLight), inverseGamma), 1.0);","#include <fog_fragment>","}"].join("\n"),vertexShader:["precision highp float;","attribute vec4 tangent;","varying float height;","varying vec3 tangentSpaceViewDirection;","varying vec3 vViewVector;","varying vec3 vWorldPosition;","varying vec4 colorMap;","varying vec2 vUv;","varying vec3 displacedNormal;","varying mat3 modelMatrixMat3;","uniform float sizeOfOceanPatch;","uniform float linearScatteringTotalScatteringWaveHeight;","uniform float linearScatteringHeightOffset;","uniform sampler2D displacementMap;","uniform mat4 matrixWorld;","#include <fog_pars_vertex>","vec2 vec2Modulo(vec2 inputUV){","return (inputUV - floor(inputUV));","}","void main() {","//Set up our displacement map","vec3 offsetPosition = position;","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","vViewVector = worldPosition.xyz - cameraPosition;","modelMatrixMat3 = mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz );","vec2 cameraOffset = (vec2(cameraPosition.x, -cameraPosition.z) / sizeOfOceanPatch);","vec2 uvOffset = uv + cameraOffset;","vec3 displacement = texture2D(displacementMap, uvOffset).xyz;","offsetPosition += modelMatrixMat3 * displacement;","//Normal map","vec3 scaledDisplacement = displacement / sizeOfOceanPatch;","height = (offsetPosition.z  + linearScatteringHeightOffset) / linearScatteringTotalScatteringWaveHeight;","vec3 bitangent = cross(normalize(normal.xyz), normalize(tangent.xyz));","vec3 v0 = vec3(uvOffset, 0.0);","v0 = v0 + scaledDisplacement;","vec3 vt = v0 + (1.0 / 12.0) * normalize(tangent.xyz);","vec3 vb = v0 + (1.0 / 12.0) * normalize(bitangent.xyz);","vec3 displacementVT = texture2D(displacementMap, vt.xy).xyz;","vt = vt + scaledDisplacement;","vec3 displacementVB = texture2D(displacementMap, vb.xy).xyz;","vb = vb + scaledDisplacement;","displacedNormal = normalize(cross(vt - v0, vb - v0));","//Set up our UV maps","vUv = uv;","//Have the water fade from dark blue to teal as it approaches the shore.","colorMap = vec4(displacement.xyz, 1.0);","//Add support for three.js fog","vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);","vWorldPosition = (projectionMatrix * mvPosition).xyz;","#include <fog_vertex>","gl_Position = projectionMatrix * modelViewMatrix * vec4(offsetPosition, 1.0);","}"].join("\n")};AWater.AOcean.OceanPatch=function(parentOceanGrid,initialPosition){let scene=parentOceanGrid.scene;this.initialPosition=initialPosition;this.position=new THREE.Vector3;this.parentOceanGrid=parentOceanGrid;let geometry=new THREE.PlaneBufferGeometry(parentOceanGrid.patchSize,parentOceanGrid.patchSize,parentOceanGrid.patchVertexSize,parentOceanGrid.patchVertexSize);THREE.BufferGeometryUtils.computeTangents(geometry);this.plane=new THREE.Mesh(geometry,parentOceanGrid.oceanMaterial.clone());this.plane.rotateX(-Math.PI*.5);scene.add(this.plane);const windVelocity=new THREE.Vector2(this.parentOceanGrid.windVelocity.x,this.parentOceanGrid.windVelocity.y);const windVelocityMagnitude=windVelocity.length();const windVelocityDirection=windVelocity.divideScalar(windVelocityMagnitude);this.plane.material.uniforms.smallNormalMapVelocity.value.set(this.parentOceanGrid.randomWindVelocities[0],this.parentOceanGrid.randomWindVelocities[1]);this.plane.material.uniforms.largeNormalMapVelocity.value.set(this.parentOceanGrid.randomWindVelocities[2],this.parentOceanGrid.randomWindVelocities[3]);this.plane.material.uniforms.lightScatteringAmounts.value.copy(this.parentOceanGrid.data.light_scattering_amounts);this.plane.material.uniforms.smallNormalMapStrength.value=this.parentOceanGrid.data.small_normal_map_strength;this.plane.material.uniforms.largeNormalMapStrength.value=this.parentOceanGrid.data.large_normal_map_strength;this.plane.material.uniforms.linearScatteringHeightOffset.value=this.parentOceanGrid.data.linear_scattering_height_offset;this.plane.material.uniforms.linearScatteringTotalScatteringWaveHeight.value=this.parentOceanGrid.data.linear_scattering_total_wave_height;let self=this;this.tick=function(time){self.plane.material.uniforms.displacementMap.value=self.parentOceanGrid.oceanHeightComposer.displacementMap;self.plane.material.uniforms.refractionCubeMap.value=self.parentOceanGrid.refractionCubeCamera.renderTarget.texture;self.plane.material.uniforms.reflectionCubeMap.value=self.parentOceanGrid.reflectionCubeCamera.renderTarget.texture;self.plane.material.uniforms.depthCubeMap.value=self.parentOceanGrid.depthCubeCamera.renderTarget.texture;self.plane.material.uniforms.smallNormalMap.value=self.parentOceanGrid.smallNormalMap;self.plane.material.uniforms.largeNormalMap.value=self.parentOceanGrid.largeNormalMap;self.plane.material.uniforms.matrixWorld.value.copy(self.plane.matrixWorld);if(self.parentOceanGrid.brightestDirectionalLight){const brightestDirectionalLight=self.parentOceanGrid.brightestDirectionalLight;const color=brightestDirectionalLight.color;const intensity=brightestDirectionalLight.intensity;self.plane.material.uniforms.brightestDirectionalLight.value.set(color.r*intensity,color.g*intensity,color.b*intensity)}else{self.plane.material.uniforms.brightestDirectionalLight.value.set(1,1,1)}self.plane.material.uniforms.t.value=time*.001}};AWater.AOcean.OceanGrid=function(data,scene,renderer,camera){this.scene=scene;this.renderer=renderer;this.camera=camera;this.cameraWorldPosition=new THREE.Vector3;this.oceanPatches=[];this.oceanPatchIsInFrustrum=[];this.drawDistance=data.draw_distance;this.patchSize=data.patch_size;this.dataPatchSize=data.patch_size;this.patchVertexSize=data.patch_vertex_size;this.heightOffset=data.height_offset;this.data=data;this.time=0;this.smallNormalMap;this.largeNormalMap;this.windVelocity=data.wind_velocity;const randomAngle1=Math.random()*2*Math.PI;const randomAngle2=Math.random()*2*Math.PI;this.randomWindVelocities=[2*Math.cos(randomAngle1),2*Math.sin(randomAngle1),1*Math.cos(randomAngle2),1*Math.sin(randomAngle2)];this.raycaster=new THREE.Raycaster(new THREE.Vector3(0,100,0),this.downVector);this.cameraFrustum=new THREE.Frustum;this.brightestDirectionalLight=false;this.windVelocity.x=Math.abs(this.data.wind_velocity.x)<.01?.01:this.windVelocity.x;this.windVelocity.y=Math.abs(this.data.wind_velocity.y)<.01?.01:this.windVelocity.y;const textureLoader=new THREE.TextureLoader;let smallNormalMapTexturePromise=new Promise((function(resolve,reject){textureLoader.load(data.small_normal_map,(function(texture){resolve(texture)}))}));smallNormalMapTexturePromise.then((function(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;texture.magFilter=THREE.LinearFilter;texture.minFilter=THREE.LinearMipmapLinearFilter;texture.encoding=THREE.LinearEncoding;texture.format=THREE.RGBAFormat;self.smallNormalMap=texture}),(function(err){console.error(err)}));let largeNormalMapTexturePromise=new Promise((function(resolve,reject){textureLoader.load(data.large_normal_map,(function(texture){resolve(texture)}))}));largeNormalMapTexturePromise.then((function(texture){texture.wrapS=THREE.RepeatWrapping;texture.wrapT=THREE.RepeatWrapping;texture.magFilter=THREE.LinearFilter;texture.minFilter=THREE.LinearMipmapLinearFilter;texture.encoding=THREE.LinearEncoding;texture.format=THREE.RGBAFormat;self.largeNormalMap=texture}),(function(err){console.error(err)}));this.numberOfOceanHeightBands=5;this.beginsFadingOutAtHeight=[];this.vanishingHeight=[];let distanceBetweenBands=80;for(let i=0;i<this.numberOfOceanHeightBands;++i){this.beginsFadingOutAtHeight.push(distanceBetweenBands*i);this.vanishingHeight.push(0)}this.reflectionCubeRenderTarget=new THREE.WebGLCubeRenderTarget(512,{});this.reflectionCubeCamera=new THREE.CubeCamera(50,1e4,this.reflectionCubeRenderTarget);this.scene.add(this.reflectionCubeCamera);this.refractionCubeRenderTarget=new THREE.WebGLCubeRenderTarget(512,{mapping:THREE.CubeRefractionMapping});this.refractionCubeCamera=new THREE.CubeCamera(.1,.5*this.drawDistance,this.refractionCubeRenderTarget);this.scene.add(this.refractionCubeCamera);this.depthCubeMapRenderTarget=new THREE.WebGLCubeRenderTarget(512,{mapping:THREE.CubeRefractionMapping,type:THREE.FloatType});this.depthCubeCamera=new THREE.CubeCamera(.1,.5*this.drawDistance,this.depthCubeMapRenderTarget);this.scene.add(this.depthCubeCamera);this.oceanHeightBandLibrary=new AWater.AOcean.LUTlibraries.OceanHeightBandLibrary(this);this.oceanHeightComposer=new AWater.AOcean.LUTlibraries.OceanHeightComposer(this);this.oceanMaterial=new THREE.ShaderMaterial({vertexShader:AWater.AOcean.Materials.Ocean.waterMaterial.vertexShader,fragmentShader:AWater.AOcean.Materials.Ocean.waterMaterial.fragmentShader,side:THREE.DoubleSide,transparent:true,lights:false,fog:true});this.oceanMaterial.onBeforeCompile=shader=>{shader.vertexShader=shader.vertexShader.replace("#include <fog_pars_vertex>",THREE.fogParsVert);shader.vertexShader=shader.vertexShader.replace(`#include <fog_vertex>`,THREE.fogVert);shader.fragmentShader=shader.fragmentShader.replace(`#include <fog_pars_fragment>`,THREE.fogParsFrag);shader.fragmentShader=shader.fragmentShader.replace(`#include <fog_fragment>`,THREE.fogFrag)};this.oceanMaterial.uniforms=AWater.AOcean.Materials.Ocean.waterMaterial.uniforms;this.oceanMaterial.uniforms.sizeOfOceanPatch.value=this.patchSize;let self=this;this.positionPassMaterial=new THREE.ShaderMaterial({vertexShader:AWater.AOcean.Materials.Ocean.positionPassMaterial.vertexShader,fragmentShader:AWater.AOcean.Materials.Ocean.positionPassMaterial.fragmentShader,side:THREE.DoubleSide,transparent:false,lights:false});this.positionPassMaterial.uniforms=AWater.AOcean.Materials.Ocean.positionPassMaterial.uniforms;this.positionPassMaterial.uniforms.worldMatrix.value=this.camera.matrixWorld;let maxHalfPatchesPerSide=Math.ceil((this.drawDistance+this.patchSize)/this.patchSize);let drawDistanceSquared=this.drawDistance*this.drawDistance;for(let x=-maxHalfPatchesPerSide;x<maxHalfPatchesPerSide;++x){for(let y=-maxHalfPatchesPerSide;y<maxHalfPatchesPerSide;++y){let xCoord=x*this.patchSize;let yCoord=y*this.patchSize;if(x*x+y*y<=drawDistanceSquared){this.oceanPatches.push(new AWater.AOcean.OceanPatch(this,new THREE.Vector3(xCoord,this.heightOffset,yCoord)))}}}this.numberOfPatches=this.oceanPatches.length;this.tick=function(time){if(this.brightestDirectionalLight===false){for(let i=0,numItems=self.scene.children.length;i<numItems;++i){let child=self.scene.children[i];if(child.type==="DirectionalLight"&&(this.brightestDirectionalLight===false||child.intensity>self.brightestDirectionalLight.intensity)){self.brightestDirectionalLight=child}}}self.cameraWorldPosition.setFromMatrixPosition(self.camera.matrixWorld);self.time=time;let cameraXZOffset=self.cameraWorldPosition.clone();cameraXZOffset.y=this.heightOffset;for(let i=0;i<self.oceanPatches.length;++i){self.oceanPatches[i].plane.position.copy(self.oceanPatches[i].initialPosition).add(cameraXZOffset)}self.cameraFrustum.setFromProjectionMatrix(self.camera.children[0].projectionMatrix.clone().multiply(self.camera.children[0].matrixWorldInverse));for(let i=0;i<self.oceanPatches.length;++i){self.oceanPatches[i].plane.visible=false}self.depthCubeCamera.position.copy(self.cameraWorldPosition);self.reflectionCubeCamera.position.copy(self.cameraWorldPosition);self.refractionCubeCamera.position.copy(self.cameraWorldPosition);self.scene.overrideMaterial=self.positionPassMaterial;self.depthCubeCamera.update(self.renderer,self.scene);self.scene.overrideMaterial=null;self.reflectionCubeCamera.update(self.renderer,self.scene);self.refractionCubeCamera.update(self.renderer,self.scene);for(let i=0;i<self.oceanPatches.length;++i){self.oceanPatches[i].plane.visible=true}self.oceanHeightBandLibrary.tick(time);self.oceanHeightComposer.tick();for(let i=0,numOceanPatches=self.oceanPatches.length;i<numOceanPatches;++i){if(self.cameraFrustum.intersectsObject(self.oceanPatches[i].plane)){self.oceanPatches[i].tick(time)}else{self.oceanPatches[i].visible=false}}}};AFRAME.registerComponent("ocean-state",{oceanGrid:null,oceanRenderer:null,schema:{draw_distance:{type:"number",default:1280},patch_size:{type:"number",default:256},patch_data_size:{type:"number",default:256},patch_vertex_size:{type:"number",default:140},wave_scale_multiple:{type:"number",default:1},number_of_octaves:{type:"number",default:128},wind_velocity:{type:"vec2",default:{x:4,y:3.5}},height_offset:{type:"number",default:0},large_normal_map:{type:"string",default:"img/water-normal-1.png"},small_normal_map:{type:"string",default:"img/water-normal-2.png"},large_normal_map_strength:{type:"number",default:.45},small_normal_map_strength:{type:"number",default:.35},light_scattering_amounts:{type:"vec3",default:{x:88,y:108,z:112}},linear_scattering_height_offset:{type:"number",default:10},linear_scattering_total_wave_height:{type:"number",default:20}},init:function(){let renderer=this.el.sceneEl.renderer;let scene=this.el.sceneEl.object3D;let camera=this.el.sceneEl.camera.el.object3D;let self=this;scene.updateMatrixWorld();this.oceanGrid=new AWater.AOcean.OceanGrid(this.data,scene,renderer,camera);this.tick=function(time,timeDelta){this.oceanGrid.tick(time)}},tick:function(time,timeDelta){}});AFRAME.registerPrimitive("a-ocean",{defaultComponents:{"ocean-state":{}}});
